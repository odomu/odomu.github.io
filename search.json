[{"title":"常用工具类","path":"/2022/12/23/常用工具类/","content":"HttpUtil(连接池)/** * 带连接池的http访问工具 */@Slf4jpublic class HttpUtil &#123; // PHttpClient连接池管理 public static PoolingHttpClientConnectionManager cm = null; // httpClient public static CloseableHttpClient httpClient = null; // 默认超时时间 private static final int DEFAULT_TIME_OUT = 60; // 最大连接数 private static final int COUNT = 60; // 最多连接数 private static final int TOTAL_COUNT = 80; // 连接存活时间 private static final int HTTP_DEFAULT_KEEP_TIME = 15; /** * 初始化连接池 */ public static void initPools() throws Exception &#123; if (httpClient == null) &#123; // 忽略https证书验证 SSLContext sslContext = SSLContexts.custom().useTLS().loadTrustMaterial(null, (x509Certificates, s) -&gt; true).build(); Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create() .register(&quot;http&quot;, PlainConnectionSocketFactory.getSocketFactory()) .register(&quot;https&quot;, new SSLConnectionSocketFactory(sslContext, SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)) .build(); // 开启连接池 cm = new PoolingHttpClientConnectionManager(registry); cm.setDefaultMaxPerRoute(COUNT); cm.setMaxTotal(TOTAL_COUNT); // 设置连接重试 HttpRequestRetryHandler httpRequestRetryHandler = (exception, executionCount, context) -&gt; &#123; if (executionCount &gt;= 3) &#123; return false; &#125; else if (exception instanceof NoHttpResponseException) &#123; return true; &#125; else if (exception instanceof SSLHandshakeException) &#123; return false; &#125; else if (exception instanceof InterruptedIOException) &#123; return false; &#125; else if (exception instanceof UnknownHostException) &#123; return false; &#125; else if (exception instanceof ConnectTimeoutException) &#123; return false; &#125; else if (exception instanceof SSLException) &#123; return false; &#125; else &#123; HttpClientContext clientContext = HttpClientContext.adapt(context); HttpRequest request = clientContext.getRequest(); return !(request instanceof HttpEntityEnclosingRequest); &#125; &#125;; // 创建httpClient httpClient = HttpClients.custom() .setConnectionManager(cm) .setKeepAliveStrategy(connectionKeepAliveStrategy) .setRetryHandler(httpRequestRetryHandler) .evictExpiredConnections() .evictIdleConnections(30, TimeUnit.SECONDS) .build(); &#125; &#125; public static CloseableHttpClient getHttpClient() &#123; return httpClient; &#125; public static PoolingHttpClientConnectionManager getHttpConnectionManager() &#123; return cm; &#125; public static String doPost(String url, Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers, String contentType, int timeout) &#123; List&lt;NameValuePair&gt; pairs = new ArrayList&lt;&gt;(); if (ObjectUtil.isNotEmpty(params)) &#123; for (String key : params.keySet()) &#123; pairs.add(new BasicNameValuePair(key, params.get(key))); &#125; &#125; return executePost(url, pairs, headers, contentType, timeout); &#125; /** * 执行post请求 * @param uri 请求链接 * @param pairs 请求参数 * @param headers 请求头 * @param contentType 内容类型 * @param timeout 请求超时 * @return 请求结果 */ public static String executePost(String uri, List&lt;NameValuePair&gt; pairs, Map&lt;String, String&gt; headers, String contentType, int timeout) &#123; HttpEntity httpEntity = null; HttpEntityEnclosingRequestBase method = null; String responseBody = &quot;&quot;; try &#123; if (httpClient == null) &#123; initPools(); &#125; contentType = contentType == null ? MediaType.APPLICATION_FORM_URLENCODED_VALUE : contentType; method = (HttpEntityEnclosingRequestBase) getRequestMethod(uri, HttpPost.METHOD_NAME, contentType, timeout, headers); StringEntity stringEntity = null; // 判断是否json if (MediaType.APPLICATION_JSON_UTF8_VALUE.contains(contentType)) &#123; JSONObject paramMap = new JSONObject(); if (pairs != null &amp;&amp; pairs.size() &gt; 0) &#123; for (NameValuePair pair : pairs) &#123; paramMap.put(pair.getName(), pair.getValue()); &#125; &#125; String string = (pairs != null &amp;&amp; pairs.size() != 0) ? paramMap.toString() : &quot;&quot;; stringEntity = new StringEntity(string, ContentType.APPLICATION_JSON); &#125; else &#123; stringEntity = new UrlEncodedFormEntity(pairs, StandardCharsets.UTF_8); &#125; stringEntity.setContentEncoding(StandardCharsets.UTF_8.name()); stringEntity.setContentType(contentType); method.setEntity(stringEntity); HttpContext context = HttpClientContext.create(); // 发送请求 CloseableHttpResponse httpResponse = httpClient.execute(method, context); httpEntity = httpResponse.getEntity(); if (httpEntity != null) &#123; responseBody = EntityUtils.toString(httpEntity, StandardCharsets.UTF_8); &#125; &#125; catch (Exception e) &#123; if (method != null) &#123; method.abort(); &#125; &#125; finally &#123; if (httpEntity != null) &#123; try &#123; EntityUtils.consumeQuietly(httpEntity); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125; &#125; return responseBody; &#125; /** * 执行get请求 * @param uri 请求链接 * @param headers 请求头 * @param contentType 内容类型 * @param timeout 请求超时 * @return 请求结果 */ public static String executeGet(String uri, Map&lt;String, String&gt; headers, String contentType, int timeout) &#123; HttpEntity httpEntity = null; HttpRequestBase method = null; String responseBody = &quot;&quot;; try &#123; if (httpClient == null) &#123; initPools(); &#125; contentType = contentType == null ? MediaType.APPLICATION_FORM_URLENCODED_VALUE : contentType; method = getRequestMethod(uri, HttpGet.METHOD_NAME, contentType, timeout, headers); HttpContext context = HttpClientContext.create(); CloseableHttpResponse httpResponse = httpClient.execute(method, context); httpEntity = httpResponse.getEntity(); if (httpEntity != null) &#123; responseBody = EntityUtils.toString(httpEntity, StandardCharsets.UTF_8); &#125; &#125; catch (Exception e) &#123; if (method != null) &#123; method.abort(); &#125; log.error(&quot;exception&quot;, e); &#125; finally &#123; if (httpEntity != null) &#123; try &#123; EntityUtils.consumeQuietly(httpEntity); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125; &#125; return responseBody; &#125; private static final ConnectionKeepAliveStrategy connectionKeepAliveStrategy = (response, context) -&gt; &#123; HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE)); while (it.hasNext()) &#123; HeaderElement he = it.nextElement(); String param = he.getName(); String value = he.getValue(); if (value != null &amp;&amp; &quot;timeout&quot;.equalsIgnoreCase(param)) &#123; try &#123; return Long.parseLong(value) * 1000; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125; &#125; return HTTP_DEFAULT_KEEP_TIME * 1000L; &#125;; /** * 获取Http请求方法 * @param uri 请求链接 * @param methodName 请求方式 * @param contentType 内容类型 * @param timeout 超时时间 * @param headers 请求头 * @return Http请求方法 */ private static HttpRequestBase getRequestMethod(String uri, String methodName, String contentType, int timeout, Map&lt;String, String&gt; headers) throws Exception &#123; if (httpClient == null) &#123; initPools(); &#125; HttpRequestBase method = null; if (timeout &lt;= 0) &#123; timeout = DEFAULT_TIME_OUT; &#125; RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(timeout * 1000) .setConnectTimeout(timeout * 1000) .setConnectionRequestTimeout(timeout * 1000) .setContentCompressionEnabled(true) .setRedirectsEnabled(true) .setRelativeRedirectsAllowed(true) .build(); if (HttpPut.METHOD_NAME.equalsIgnoreCase(methodName)) &#123; method = new HttpPut(uri); &#125; else if (HttpPost.METHOD_NAME.equalsIgnoreCase(methodName)) &#123; method = new HttpPost(uri); &#125; else if (HttpGet.METHOD_NAME.equalsIgnoreCase(methodName)) &#123; method = new HttpGet(uri); &#125; else &#123; method = new HttpPost(uri); &#125; if (contentType == null || &quot;&quot;.equals(contentType)) &#123; contentType = MediaType.APPLICATION_FORM_URLENCODED_VALUE; &#125; if (headers != null &amp;&amp; headers.keySet().size() &gt; 0) &#123; for (String key : headers.keySet()) &#123; method.addHeader(key, headers.get(key)); &#125; &#125; method.addHeader(&quot;Content-Type&quot;, contentType); method.addHeader(&quot;Accept&quot;, contentType); method.setConfig(requestConfig); return method; &#125;&#125;"},{"title":"Spring配置方式","path":"/2022/12/23/Spring配置方式/","content":"Spring的配置发展 Spring IOC有一个非常核心的概念——Bean。由Spring容器来负责对Bean的实例化，装配和管理。XML是用来描述Bean最为流行的配置方式。 但随着Spring的日益发展，越来越多的人对Spring提出了批评。“Spring项目大量的烂用Xml”就是最为严励的一个批评。由于Spring会把几乎所有的业务类都以Bean的形式配置在XML文件中，因此产生了大量的XML文件，使得整个项目变得更加复杂，并且使Bean失去了编译时的类型安全检查。 随着JDK1.5的发布，其中引入了一个非常重要的特性——Annotations(注解)。注释是源代码的标签，这些标签可以在源代码层进行处理或通过编译器把它熔入到class文件中。在JDK1.5以后的版本中，注释成为了一个主要的配置选项。Spring使用注释来描述Bean的配置与采用XML相比，因类注释是在一个类源代码中，可以获得类型安全检查的好处。可以良好的支持重构。 第一阶段 Xml文件 Spring1.x时代，开发基本上都是使用Xml文件配置Bean。但是随着项目不断的增大，产生了大量的配置文件，需要频繁的在类和配置文件进行切换，给开发人员带来了不必要的成本。 第二阶段 注解配置 Spring2.x时代，随着Jdk1.5带来了对注解的支持，Spring也随之提供了声明Bean的注解, 大大的减少了配置文件，同时也大大简化了项目的开发。那么，问题来了，究竟是应该使用xml还是注解呢？ 应用的基本配置用xml，比如：数据源、资源文件等 业务开发用注解，比如：Service中注入bean等IOC AOP（切面编程）建议用XML 第三阶段 Java配置 Spring3.x时代到现在，Spring提供了Java配置的能力，使Java配置更好的理解，现在都推荐使用Java配置。 Java配置相关注解 @Configuration、@ConditionalOnProperty、@ConditionalOnClass、@ConfigurationProperties、@PropertySource、@Value、@Profile、@EnableConfigurationProperties、@EnableAutoConfiguration、@SpringBootConfiguration、@SpringBootApplication","tags":["学习","Java","Spring"],"categories":["Spring"]},{"title":"关于","path":"/about/index.html","content":"关于时间线**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**2023 年 1 月 1 日博客主题切换为stellar2021 年 10 月 1 日博客正式上线，采用Hexo + Vercel的方式部署博客，主题采用Volantis"},{"title":"朋友","path":"/friends/index.html","content":""}]